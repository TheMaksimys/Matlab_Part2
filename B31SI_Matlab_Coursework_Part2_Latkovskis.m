%% This is the code for the MATLAB assignment Part 2 for B31SI course
% The program emulates the wireless transmission of the repetitive QPSK-coded
% bitstream over the Rayleigh channel with AWGN. The emulation result is
% the Bit-Error-Rate versus the SNR of the recieved signal plot.

clear all
clf

NumberOfBits=500000; % Number of data bits to be generated by the bit source
BitRate = 541600; % Bits/second
fs = 270800; % Sampling frequency, Hz
L = 3; % Upper limit for the number of bit repetitions (Time-diversity) [min=2]

%% Bit source
Vhigh=1; % Voltage level for HIGH bit state (Here normalized to 1 Volt)
Vlow=0;  % Voltage level for LOW bit state

BinSeq=randi([Vlow Vhigh],1,NumberOfBits); % Generation of random binary bit sequence
[BinSeqmin, BinSeqmax]=bounds(BinSeq); % Function to check upper and lower boundaries of the generated sequence 

for length=2:1:L % Function to compute the theoretical and simulated BERs for QPSK with repetition coding 
    % Performing the repetition coding for L-repetitions
    BinSeqReshaped=transpose(reshape(BinSeq, 2, NumberOfBits/2)); % Reshaping bit sequence for repetition process
    BinSeqRep=zeros(NumberOfBits/2,2*length); % Creating zeros array for the transmitted bit sequence

    for i=1:1:NumberOfBits/2
        BinSeqRep(i,:)=repmat(BinSeqReshaped(i,:),1,length); % Performing repetition coding
    end

    BinSeqRep=reshape(BinSeqRep.', 1, []); % Reshaping obtained matrix into the array

    %% QPSK Modulation (Grey coding)
    BinOfs=(Vhigh-BinSeqRep*2); % Converting binary states  to [-a;a] format
    BinSeqIQ=zeros(2,(length*NumberOfBits/2)); % Creating an empty matrix for I and Q component allocation for the L-repetitions

    BinSeqIQ(1,:)=BinOfs(:,1:2:end);  % Deternmining the In-phase component 
    BinSeqIQ(2,:)=BinOfs(:,2:2:end);  % Deternmining the Quadrature component

    S=zeros(1,(length*NumberOfBits/2)); % Signal to be transmitted through the channel for the L-repetitions
    Theta=pi/4; % Angle on the Constellation diagram
    S(1,:)=1j*sin(Theta)*BinSeqIQ(1,:)+cos(Theta)*BinSeqIQ(2,:); % Gray coding of the input bitstream

    %% Rayleigh Fading Channel

    b=0.5; % Channel variance
    fm=91; % Maximum Doppler frequency
    N1=9; % Number of sinusoids for In-phase component
    N2=10; % Number of sinusoids for Quadrature component
    Ts = (NumberOfBits/BitRate)*length-1/fs; % Message transmission period
    t=[0:1/fs:Ts]; % Time divisions for the channel simulation

    c1=zeros([1 N1]); % Generating zero vector for the In-phase sinusoinds amplitude
    c2=zeros([1 N2]); % Generating zero vector for the Quadrature sinusoinds amplitude
    f1=zeros([1 N1]); % Generating zero vector for the In-phase sinusoinds frequency offset
    f2=zeros([1 N2]); % Generating zero vector for the Quadrature sinusoinds frequency offset
    theta1=zeros([1 N1]); % Generating zero vector for the In-phase sinusoid phase offset
    theta2=zeros([1 N2]); % Generating zero vector for the Quadrature sinusoid phase offset

    % Computing parameters for the In-phase sinusoids
    for n = 1:N1
        c1(1,n) = sqrt(2*b/N1); % Amplitude
        theta1(1,n)=6.28*(n/(N1+1)); % Phase
        f1(1,n)=fm*sin((1.57/N1)*(n-0.5)); % Frequency
    end

    % Computing parameters for the Quadrature sinusoids
    for n = 1:N2
        c2(1,n) = sqrt(2*b/N2); % Amplitude
        theta2(1,n)=2*pi*(n/(N2+1)); % Phase
        f2(1,n)=fm*sin(((pi/2)/N2)*(n-0.5)); % Frequency
    end

    g1_n=zeros(N1, numel(t)); % Generating zero matrix for In-phase sinusoids
    g2_n=zeros(N2, numel(t)); % Generating zero matrix for Quadrature sinusoids
 
    % Generating In-phase and Quadrature sinusoids
    for i=1:1:numel(t)
        g1_n(:,i)=c1.*cos(2*pi.*f1*t(1,i)+theta1);
        g2_n(:,i)=c2.*cos(2*pi.*f2*t(1,i)+theta2);
    end

    g1=sum(g1_n,1); % Sum of In-phase sinusoids
    g2=sum(g2_n,1); % Sum of Quadrature sinusoids
    G=zeros(1, numel(t)); % Creating zeros matrix to store the Rayleigh flat fading channel
    G(1,:)=g1(1,:)+1j*g2(1,:); % Computing Rayleigh flat fading channel

    %% AWGN

    SNR = [0:2:20]; % SNR of the signal in dB
    SNR_lin=10.^(SNR/10); % SNR in linear scale
    k=2; % Number of bits in one symbol

    BERsimulated=zeros(1,numel(SNR)); % Creating zero vector to store simulated BER

    for m=1:1:numel(SNR) % Performing simulations for different SNRs

        NormRealAWGN=randn([1 numel(S)]); % Generating real component for AWGN simulation
        NormImAWGN=randn([1 numel(S)]); % Generating imaginary component for AWGN simulation

        NormAWGN=(NormRealAWGN+1j*NormImAWGN); % Computing normalized AWGN with 1/2 variance
        NoiseAmp=Vhigh/((SNR_lin(1,m))); % Computing the Average Noise power for the AWGN
        AWGN=zeros(1,numel(S));
        AWGN=(NoiseAmp).^(length/2)*NormAWGN; % Computing AWGN for the given SNR
        AWGN=AWGN/(sqrt(2*k));
        %% Emulation of the recieved signal through AWGN Rayleigh communication channel

        R=zeros(1,numel(S)); % Creating the Recieved signal matrix
        R=S.*G+AWGN; % Computing the recieved signal matrix in accordance with the system diagram

        %% Signal demodulation
%==================================================
        Rmatrix=reshape(R,length,[]);
        Gmatrix=conj(reshape(G,length,[]));
        Y=zeros(length,numel(R)/length);
        for i=1:1:length
            Y(i,:)=Gmatrix(i,:).*Rmatrix(i,:);
        end
        Rhat=zeros(1, numel(R)/length);
        Rhat=sum(Y);
%==================================================
        % This plot is purely for debugging purposes and shall not be used during the normal run
        figure (3) % Plotting everything on the figure 2
        plot(real(Rhat),imag(Rhat),'m.'); % Plotting the reconstructed signal on the constellation diagram
        grid on
        title('Reconstructed signal constellation');
 
        % Listing all allowed QPSK constellation points on the IQ diagram for the Gray coding
        Constellation00=Vhigh*exp(1j*pi/4); % Represents "00" codeword
        Constellation10=Vhigh*exp(1j*3*pi/4); % Represents "01" codeword
        Constellation11=Vhigh*exp(1j*5*pi/4); % Represents "11" codeword
        Constellation01=Vhigh*exp(1j*7*pi/4); % Represents "10" codeword
 
        MLerror=zeros(4,numel(Rhat)); % Creating Maximum likelyhood matrix
        % Computing the absolute errors with respect to the allowed constellation points
        MLerror=[abs(Rhat-Constellation00);abs(Rhat-Constellation10);abs(Rhat-Constellation11);abs(Rhat-Constellation01)];

        RecSignal=zeros(2,numel(Rhat)); % Creating the recovered signal matrix
        [RecSignal(1,:), RecSignal(2,:)] = min(MLerror); % Recovering signal using ML technique
 
        BitStreamOut=zeros(1,NumberOfBits); % Creating output bitstream vector
        for i=1:1:numel(Rhat)
            if(RecSignal(2,i)==1) % If 00 codeword is decoded, assign:
                BitStreamOut(1,2*i-1)=0; % Bit 0 to 0
                BitStreamOut(1,2*i)=0; % Bit 1 to 0
            elseif(RecSignal(2,i)==2) % If 01 codeword is decoded, assign:
                BitStreamOut(1,2*i-1)=0; % Bit 0 to 0
                BitStreamOut(1,2*i)=1; % Bit 1 to 1
            elseif(RecSignal(2,i)==3) % If 11 codeword is decoded, assign:
                BitStreamOut(1,2*i-1)=1; % Bit 0 to 1
                BitStreamOut(1,2*i)=1; % Bit 1 to 1
            elseif(RecSignal(2,i)==4) % If 10 codeword is decoded, assign:
                BitStreamOut(1,2*i-1)=1; % Bit 0 to 1 
                BitStreamOut(1,2*i)=0; % Bit 0 to 0
            end
        end
 
        %% BER computaion by comparing the bits at the bit source and the bit sink
        BERsimulated(1,m) = (sum(BinSeq~=BitStreamOut))/(NumberOfBits); % Calculating the Bit Error Ratio
 
    end

    %% Couputing theoretical BER

    BERtheoretical=zeros(1,numel(SNR)); % Creating zero vector to store theoretical BER

    for m=1:1:numel(SNR)
        BERtheoretical(1,m)=(1/factorial(length))*(1/(SNR_lin(1,m))^(length)); % Analytical formula for the Bit Error Ratio for channel with the time diversity
    end
    %% Saving the theoretical and simulated BER for the L repetition coding

    filenameout = sprintf('RepCodingBER_L%d.txt', length); % Creating filename to store the data
    save(filenameout,'BERsimulated','BERtheoretical','-ascii'); % Store the acquired data


end
%% Plotting simulated and analytical results

% Plotting Analytical and Simulated BER in the semilog scale
figure (1) % Pick figure 1

for length=2:1:L
    filenamein=sprintf('RepCodingBER_L%d.txt', length); % Find the required filename
    DataInput=load(filenamein); % Load acquired data
    semilogy(SNR,DataInput(1,:)); % Plotting simulated BER with the logaritmic Y axis
    hold on
    semilogy(SNR,DataInput(2,:)); % Plotting theoretical BER with the logaritmic Y axis
end

hold off
grid on; % Enabling grid 
%legend('Simulated BER for L=2','Analytical BER for L=2','Simulated BER for L=3', 'Analytical BER for L=3'); % Adding legend
xlabel('Eb/No (dB)'); % Labelling X axis
ylabel('Bit Error Rate'); % Labelling Y axis
title('BER for Time-diverse Gray QPSK over Rayleigh channel'); % Labelling figure

%% End of the document